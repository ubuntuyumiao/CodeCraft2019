






			        if(to_road.lane!=-1)
			             {  	
			               for( set_lane=to_road.lane;set_lane>=0;set_lane--)
			                 {
				           int car_forsee=road_array_[goal_road].
					   load[(cross_->id==road_array_[goal_road].start)?0:1][set_lane][(road_array_[goal_road].
					                            road_length-1)];
				           if((car_forsee!=0&&(car_array_[car_forsee]).state==wait_schedule)) break;
			             }
	
			          if(set_lane==-1)
				    {
			          //所去车道之前的车道的最后一辆车全是终止态 移到相应位置 更新车道 以及状态等等
				      road_->load[(cross_->id==road_->end)?0:1][i][j]=0;
				      road_array_[goal_road].load[(cross_->id==road_array_[goal_road].start)?0:1][to_road.lane][to_road.offset]=car_id;
				      check_and_delete(car_id,block_list_);
				      check_and_delete(car_id,wait_list_);
				      car_array_[car_id].state=completed;
				      car_array_[car_id].wait_anthor=false;
				      car_array_[car_id].now_road=goal_road;
				      clear_cross_proir(&car_array_[car_id],
							&road_array_[road_->id],
					                &cross_array_[cross_->id]);
				      memset(huan,-1,sizeof(huan));front_car=0;i=0;j=0;break;
				    }
				  else
				    {
				     //所去车道之前的车道的最后一辆车存在等待态 该车切换为等待态 检查锁死表 加入锁死表
				      car_array_[car_id].state=wait_schedule;
				      car_array_[car_id].wait_anthor=true;
				      car_array_[car_id].now_road=road_->id;
				      if(check_in_list(car_id,block_list_))  
				        {
					  sch_most.block=true;
					  std::cout<<"System Is Blocked at Cross: "<< cross_->id<<" of car: "<<car_id
					     <<std::endl;
					  std::cout<<"System Is Blocked at Cross: "<< cross_->id<<" of car: "<<car_id
					     <<std::endl;
					  return sch_most;
					}
			              block_list_.push_back(car_id);
				      continue;
				    }
			              }
			         else //无法加塞  检查车道最后的车位车辆信息
			           {
			             bool wait_on_anther=false;
			             int all_lane;
			              for( all_lane=0;all_lane<road_array_[goal_road].lane_num;all_lane++)
			                {
				          int car_last=road_array_[goal_road].
					  load[(cross_->id==road_array_[goal_road].start)?0:1][all_lane][(road_array_[goal_road].
					  road_length-1)];
			                  if(car_last==0) 
					   {  
				             std::cout<<"NO SPACE FOR CAR???"<<std::endl; 
				             sch_most.block=true;  return sch_most;    
					   }
					   //要去往道路被等待态车阻挡
				          else if(car_array_[car_last].state==wait_schedule)
					   {  
				                 wait_on_anther=true;    
						 break;
				           }
			                }
			                 if(wait_on_anther)
					  {
				            car_array_[car_id].now_road=road_->id;
					    car_array_[car_id].next_road=goal_road;
					    car_array_[car_id].state=wait_schedule;
					    car_array_[car_id].wait_anthor=true;
					    if(check_in_list(car_id,block_list_)) 
					      {
					        sch_most.block=true;
					        std::cout<<"System Is Blocked at Cross: "<< cross_->id<<" of car: "<<car_id<<std::endl;
					        std::cout<<"System Is Blocked at Cross: "<< cross_->id<<" of car: "<<car_id<<std::endl;
					        return sch_most;
					      }
					    block_list_.push_back(car_id);
				            memset(huan,-1,sizeof(huan));front_car=0;i=0;j=0;break;
			                  }
				         else
					  {  
				            //不能进入车道 因为都被终止态车堵住  该车也置为终止态
				            road_->load[(cross_->id==road_->end)?0:1][i][j]=0;
				  	    road_->load[(cross_->id==road_->end)?0:1][i][0]=car_id;
                                            check_and_delete(car_id,block_list_);
					    check_and_delete(car_id,wait_list_);
					    car_array_[car_id].state=completed;
					    car_array_[car_id].wait_anthor=false;
					    car_array_[car_id].now_road=road_->id;
					    car_array_[car_id].next_road=goal_road;
					    memset(huan,-1,sizeof(huan));front_car=0;i=0;j=0;break;
				          }
			               }





bool sch_allcross_drive(Car* car_array,int min_car_id,int max_car_id,
			 Cross* cross_array,int min_cross_id,int max_cross_id,
			 Road* road_array,
			 Magic_garage* garage,
			 Road map_[][MAX_CROSS],
			 int T,
			 std::vector<int> &wait_list_,std::vector<int> &bloack_list_
			)
{    
          bloack_list_.erase(bloack_list_.begin(),bloack_list_.end());
           if(T==3)std::cout<<"!!! Research !!!"<<std::endl;
       for(int sch_cross_drive=min_cross_id;sch_cross_drive<=max_cross_id;sch_cross_drive++)
       {   
	 if(wait_list_.size()==0) {return false;  break;}
	    //将所有车 的waitanthor初始化
	    init_waitanthor(car_array,min_car_id,max_car_id);
// 	    std::cout<<std::endl;
	    //因为道路上的所有车都已是终止态 所以先调度那个方向的都可以 如果发车的可行驶距离超过道路长度 直接放到路口
	    /******需要调度的路口id升序存于cur_cross_road中    起始下标为 array_offset******/
	    int cur_cross_road[4];
	    std::memcpy(cur_cross_road,cross_array[sch_cross_drive].road_id,sizeof(cur_cross_road));
	    int array_offset=3;
	  for(int i=0;i<4;i++)
	    if(cur_cross_road[i]!=-1)
	      if(road_array[cur_cross_road[i]].flag_twoway!=1)                      //该道路为单向道，且该路口不是起点
		if(sch_cross_drive!=road_array[cur_cross_road[i]].start)  cur_cross_road[i]=-1;
	    std::sort(cur_cross_road,cur_cross_road+4);    
	  //去掉不存在的道路 或者不调度 不进入该交叉口的道路
	    for(;array_offset>=0;array_offset--)
	    {
	      if((array_offset==0)&&(cur_cross_road[array_offset]!=-1)) break;
	      if(cur_cross_road[array_offset]==-1) { array_offset+=1;  break;}
	    } 
	  int road_complete[4]={0,0,0,0}; 
	  for(int i=0;i<array_offset;i++) road_complete[i]=1;
	  /******需要调度的道路id升序存于cur_cross_road中    起始下标为 array_offset******/
	  //先从最小id道路开始
          bool all_complete=false;		  
          while(!all_complete)
	    {    
	     
	     int sch_road_drive_offset=array_offset;
	     sch_pos sch_car_road;
	     sch_car_road.next_road = cur_cross_road[array_offset];
 	   for(;sch_road_drive_offset<4;)
	    {  
	      if(T>=3)
	        {
	          std::cout<<"Cross: "<<sch_cross_drive<<" "
	                 <<"Road: "  <<sch_car_road.next_road<<" " 
			 <<wait_list_.size()<<" " <<T<<" "<<wait_list_.size()<<" " <<car_array[wait_list_[0]].id
			 <<std::endl;	 
	          if((sch_cross_drive==8)&&(sch_car_road.next_road==5011))
	            {	 
		     debug_dir_tocross(road_array,14,14,cross_array);	  
	            }
                  sleep(1);
	        }
	      sch_car_road= sch_most_prior(car_array, 
			    &road_array[sch_car_road.next_road],
			    &cross_array[sch_cross_drive],
			    sch_road_drive_offset,cur_cross_road,
			    cross_array,road_array,map_,
			    wait_list_,bloack_list_,T) ;
		  if(sch_car_road.block==true)
		     {
		       while(!bloack_list_.empty())
			{
			  std::cout<<bloack_list_[0]<<"  ";
			  bloack_list_.erase(bloack_list_.begin());
			}
		       return true;
		     }
	          if(sch_car_road.road_completed==true) 
		   { 
		     //此处造成路口不能轮询周边道路
		     road_complete[sch_road_drive_offset]=1; 
		     sch_road_drive_offset++;
		     if(sch_road_drive_offset>=4) break;
		     sch_car_road.next_road=cur_cross_road[sch_road_drive_offset];
		   }
	           else
		    {
		      if(sch_car_road.next_road==-1) { out(" Logis error!!!"); return true; }
		      //该道路还没调度 优先级被抢
		      else
		       {
		         road_complete[sch_road_drive_offset]=0;
		         sch_road_drive_offset++;
		         if(sch_road_drive_offset>=4) break;
		       }
		     }	
	         }
	      if((road_complete[0]==1)&&(road_complete[1]==1)&&(road_complete[2]==1)&&(road_complete[3]==1))  all_complete=true;
	        else
		 {
		   sch_road_drive_offset=array_offset; sch_car_road.next_road = cur_cross_road[array_offset];
		 }
	    }
      }
  return false;
}
